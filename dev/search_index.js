var documenterSearchIndex = {"docs":
[{"location":"#Overview","page":"-","title":"Overview","text":"","category":"section"},{"location":"","page":"-","title":"-","text":"The goal of this package is to provide an intuitive and mathematically sound interface for taking expectations of random variables and their higher-order functions (i.e., if X sim N(0 1), what is mathbbEsin(X)?).","category":"page"},{"location":"","page":"-","title":"-","text":"The underlying random variables are assumed to be distributions from Distributions.jl. Currently, only univariate distributions are supported.","category":"page"},{"location":"#Installation","page":"-","title":"Installation","text":"","category":"section"},{"location":"","page":"-","title":"-","text":"To install, run:","category":"page"},{"location":"","page":"-","title":"-","text":"using Pkg\npkg\"add Expectations Distributions\"\n\nusing Expectations, Distributions","category":"page"},{"location":"#The-Expectation-Operator","page":"-","title":"The Expectation Operator","text":"","category":"section"},{"location":"","page":"-","title":"-","text":"The key object in this package is an expectation operator, or an object <: Expectation. These include all objects capable of being called on a function; e.g. that support a method function (e::Expectation)(f::Function). You can create these as following:","category":"page"},{"location":"","page":"-","title":"-","text":"\ndist = Normal();\nE = expectation(dist)","category":"page"},{"location":"","page":"-","title":"-","text":"You can also choose algorithms and default parameters (see below for list):","category":"page"},{"location":"","page":"-","title":"-","text":"E = expectation(dist, Gaussian; n = 30) # Could have done expectation(dist) or expectation(dist; n = 30)","category":"page"},{"location":"","page":"-","title":"-","text":"These objects can then be applied to functions:","category":"page"},{"location":"","page":"-","title":"-","text":"E(x -> x)\nE(x -> x^2)","category":"page"},{"location":"","page":"-","title":"-","text":"There is also a convenience function to evaluate expectations directly, without returning the operator:","category":"page"},{"location":"","page":"-","title":"-","text":"f = x -> x^2\nexpectation(f, dist)","category":"page"},{"location":"","page":"-","title":"-","text":"In general, expectation(f, dist, ...) is equivalent to E(f), where E = expectation(dist, ...).","category":"page"},{"location":"#IterableExpectation","page":"-","title":"IterableExpectation","text":"","category":"section"},{"location":"","page":"-","title":"-","text":"The only concrete subtype of Expectation currently supported is IterableExpectation{NT, WT}. These are expectations for which we have a discrete vector of quadrature nodes and weights, either defined by user fiat, or set algorithmically. These support some additional behavior:","category":"page"},{"location":"","page":"-","title":"-","text":"nodeList = nodes(E);\nvals = map(x -> x^2, nodeList);\nE * vals\n(2E) * vals","category":"page"},{"location":"","page":"-","title":"-","text":"The above behavior, in some sense, puts the \"operator\" in \"expectation operator\"; that is, it allows it to move elements of a vector space around, and to be scalar-multiplied.","category":"page"},{"location":"#User-Defined-Nodes","page":"-","title":"User-Defined Nodes","text":"","category":"section"},{"location":"","page":"-","title":"-","text":"There are some situations where we are forced to use a specific set of nodes. In those situations, E = expectation(dist, nodes) will create the relevant object.","category":"page"},{"location":"#Mixture-Models","page":"-","title":"Mixture Models","text":"","category":"section"},{"location":"","page":"-","title":"-","text":"We also have support for univariate mixture models. The MixtureExpectation type is a struct with two fields:","category":"page"},{"location":"","page":"-","title":"-","text":"expectations, which is a list of IterableExpectation objects.\nmixtureweights, which is the mixing probabilities over the various model components.","category":"page"},{"location":"","page":"-","title":"-","text":"The mixture models are constructed using the default settings for each component distribution. (It still accepts kwargs, which are applied to each.)","category":"page"},{"location":"","page":"-","title":"-","text":"d = MixtureModel([Uniform(), Normal(), Gamma()]);\nE = expectation(d; n = 30); # n = 30 nodes for each\n@show typeof(E)\nE(x -> abs(x))","category":"page"},{"location":"","page":"-","title":"-","text":"If you want to change this, you should construct each distribution separately, and then chain them together.","category":"page"},{"location":"","page":"-","title":"-","text":"E1 = expectation(Uniform())\nE2 = expectation(Normal())\nE3 = expectation(Gamma())\n\nE = MixtureExpectation([E1, E2, E3], [1/3, 1/3, 1/3])\nE(x -> abs(x))","category":"page"},{"location":"#Supported-Distributions,-Algorithms,-Keywords,-and-Defaults","page":"-","title":"Supported Distributions, Algorithms, Keywords, and Defaults","text":"","category":"section"},{"location":"","page":"-","title":"-","text":"Here is a list of currently supported distributions, along with keyword arguments and their defaults.  ","category":"page"},{"location":"","page":"-","title":"-","text":"Distribution Name Algorithm (Julia Type) Keywords and Defaults Restrictions\nDiscrete Univariate FiniteDiscrete <: QuadratureAlgorithm N/A Support must be finite.\nContinuous Univariate Gauss-Legendre (Gaussian <: QuadratureAlgorithm) n = 500 Support must be a compact interval a b.\nContinuous Univariate QNWDist[1] (QuantileRange <: ...) n = 50, q0 = 0.001, qN = 0.999 Distribution must be nondegenerate.\nNormal <: Continuous Univariate Gauss-Hermite (...) n = 30 ...\nLogNormal <: ... Gauss-Hermite (...) n = 30 ...\nBeta <: ... Gauss-Jacobi (...) n = 32 ...\nChiSq <: ... Gauss-Laguerre (...) n = 32 ...\nUniform <: ... Gauss-Legendre (...) n = 30 ...\nExponential <: ... Gauss-Laguerre (...) n = 32 ...\nGamma <: ... Gauss-Laguerre (...) n = 32 ...\nUnivariate Trapezoidal <: ExplicitQuadratureAlgorithm N/A All nodes must be inside distribution's support.","category":"page"},{"location":"#","page":"-","title":"","text":"","category":"section"},{"location":"","page":"-","title":"-","text":"Some unbounded distributions are currently not supported (e.g., Poisson). Depending on your use case truncating may be a feasible option:","category":"page"},{"location":"","page":"-","title":"-","text":"E = expectation(Pareto()) # Throws error\nE = expectation(truncated(Pareto(),0.0,1000.0)) # Truncated Pareto on [0,1000]","category":"page"},{"location":"","page":"-","title":"-","text":"See Distributions.truncated for more. Of course, truncating the distribution also affects its properties.","category":"page"},{"location":"#Mathematical-Details-and-References","page":"-","title":"Mathematical Details and References","text":"","category":"section"},{"location":"","page":"-","title":"-","text":"The specific quadrature algorithms come from the FastGaussQuadrature.jl library, which is maintained by Alex Townsend of Cornell University. Much of the quadrature code came from the DistQuads.jl library, which is maintained by Patrick K. Mogensen at the University of Copenhagen. In addition, there are some objects contributed by individual users; see docstring for citations.","category":"page"},{"location":"","page":"-","title":"-","text":"WARNING: It is important to be aware of the deficiencies of numerical quadrature schemes. For example, it is recommended to be careful when using these methods for the following classes of functions and situations:","category":"page"},{"location":"","page":"-","title":"-","text":"Discontinuous or nondifferentiable functions (even if the function is a.e.-differentiable)\nPeriodic/oscillatory functions with a high frequency\nExtremely large numbers of quadrature nodes, which may lead to vanishingly small weights.","category":"page"},{"location":"#Contact","page":"-","title":"Contact","text":"","category":"section"},{"location":"","page":"-","title":"-","text":"If you would like to get in touch, please do one of the following:","category":"page"},{"location":"","page":"-","title":"-","text":"Issue requests: Open an issue on the package repository with the tag feature request.\nBugs: Same as above, but with the tag bug.\nPull Request: We are always open to new functionality. If you have a feature you'd like to add (say, a new distribution or algorithm), once you prepare a PR with the feature and some tests, open it in the usual way.\nOther: You can reach out to Arnav Sood at misc@arnavsood.com\nCitation: If this package was helpful in your research work, you may consider citing the package in whatever method is appropriate for your field.","category":"page"},{"location":"","page":"-","title":"-","text":"[1]: This is a quadrature scheme written by Spencer Lyon (PhD. NYU) as part of the QuantEcon project. Used with permission.","category":"page"}]
}
